namespace System.Design;

/// <summary>
/// 这个类型可以在被回收时自动释放非托管资源
/// </summary>
public abstract class AutoRelease : Release
{
    #region 说明文档
    /*问：根据Net规范，不推荐在析构函数中释放非托管对象，
      既然如此，为什么本类型要为派生类提供这个功能？
      答：作者对这个问题持有异议，因为内存泄露是一个熵增过程，
      一旦开始，它就只会恶化，不会缓解，因此必须尽最大努力避免，
      使用析构函数会产生对象老化问题，并且会浪费一点CPU资源，
      但是它付出的代价是暂时的，它能够保证对象最终仍然会被回收

      而且，在手动调用了本对象的Dispose方法以后，
      它会阻止CLR调用析构函数，因此这种做法能够防止菜鸟犯错，
      但是对有经验的开发人员来说，它的代价是不存在的
    
      重要说明：
      本类型存在以下隐患，不可滥用：
      假设有类型A和B，它们都继承自本类型，
      且它们的Dispose方法释放的是同一个非托管对象C，
      且A被回收，B没有，则：
    
      由于A释放了C，所以B虽然没有被释放，但仍然已经不可用，
      这很可能会导致令人疑惑而且难以排查的BUG，因此本类型的推荐做法如下：
    
      仅直接封装非托管对象的类型继承自本类型，其他需要释放，
      但是不直接封装非托管对象的类型继承自Release*/
    #endregion
    #region 析构函数
    /// <summary>
    /// 在本对象被回收时，自动释放非托管资源
    /// </summary>
    ~AutoRelease()
    {
        Dispose();
    }
    #endregion
}
