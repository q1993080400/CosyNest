#关于方法及属性的参数和返回值类型，应遵循以下原则：
1.如果是抽象方法，虚方法，接口中的方法，则应该尽量抽象，因为这样可以为实现者提供更大的自由
2.如果是属性，则应该尽量抽象
3.在其他情况下，方法的参数应该尽可能抽象，返回值应该尽可能具象，因为抽象的参数可以让调用者传入更多的类型，具象的返回值可以让返回值的接收者调用更多的API

#方法的参数应该尽可能的少，如果某些参数可以通过另一些参数推断出来，则这些多余的参数应该被删除

#方法的参数应该只接受方法执行过程中所直接需要的类型，举例说明，一个处理位图的API应该直接接受byte[]作为位图，而不是接受一个Stream并从中读取位图，更不应该接受一个文件路径并读取该位图文件，因为这种做法假设了参数对象的来源，使方法耦合性更高

#如果执行上一条规范确实会产生不便，可以考虑声明一个该方法的二次封装，但该方法本身应该保持独立并公开

#如果某方法无参数且有返回值，则应该通过属性来代替它，除非该方法不表示对象的状态，例如：它是一个工厂方法，如果对象是不可变的，而且访问这个属性代价较大，可以在第一次访问该属性时将它缓存起来

#除非发生歧义，则不同参数的方法尽量使用重载区分，而不是取一个新的名字，这样可以让框架看起来更加简洁，歧义包括但不限于以下两种情况：
1.方法的作用类似，但不可混淆
2.方法的参数可以被隐式转换或省略，导致很多情况下编译器不知道应该调用哪个方法，给开发者带来不必要的麻烦

#除非方法过于复杂，则应该尽量使用默认参数来代替方法重载，且该规范优先级比上一条规范更高，原因同上

#扩展方法应该放在专门的类型中，并且名称应该以Extend开头，因为作者认为扩展方法在绝大部分情况下应该通过类型的实例调用，因此将它们集中到一个比较偏僻的地方可以使框架更加简洁

#扩展方法应该全部位于System命名空间，无论它们所依赖的类型或它们的作用，因为System命名空间总是被引用，这样可以让任何渠道获得的支持扩展方法的对象，都能够使用该扩展方法

#一般应该尽量使用标准库中的泛型委托，而不是显式声明委托，除非发生以下情况之一：
1.委托的泛型参数非常复杂
2.委托的参数非常多
3.委托的参数和返回值具有特殊意义，不容易理解