问答区

问：封装程度较高的框架使用方便，封装程度较低的框架能够控制更多细节，请问如何平衡这两点？
答：本框架的设计思路是，先开发出低度封装的模块为开发提供铺垫，然后对这些模块进行二次封装，并用高度封装的模块进行实际开发（有点类似滚雪球），同时，这些不同层次的模块全部对调用者开放，如果高度封装的模块可以满足需求，则直接使用，如果不能满足，可以退回到下一层重新封装，同时，本模块的分层非常细致（请参考开发手册中的"本项目模块依赖关系图.vsdx"），这保证了高层模块不能满足需求的时候，向底层撤退的幅度尽可能少

规范区

#本框架的设计理念是：不要求框架具备商业价值，但是要求它能够帮助作者解决工作和生活中的问题，因此：
1.框架不能过于底层，因为工作和生活中的问题通常是比较高层的
2.框架不能过于特化，因为工作和生活中会碰到各种各样的问题，只专注于一件事情的框架无法满足要求

#在开发本框架的模块时，应该尽量遵循规范，但考虑到成本问题，有必要根据以下原则，对重要程度不同的模块加以区别对待：
基本原则：越泛化，适用场景越多的模块遵循的规范越严格，越特化，适用场景越少的模块遵循的规范越宽松
1.可以在其他项目中使用的模块规范严格，项目直接包含的模块规范宽松
2.服务端规范严格，客户端规范宽松
3.可见性越高的API规范越严格，可见性越低的API的规范越宽松

#本文所述的“抽象”和“具象”指的是类型的耦合程度，越抽象的类型对底层了解越少，越具象的类型对底层了解越多，类型从抽象到具象的依次排列为：函数（委托），接口，基类，派生类，结构

#凡是功能相似的类型，要么继承共同的基类，要么实现共同的接口，这样可以将多态带来的好处最大化

#执行上一条规范时，实现共同的接口优先于继承共同的基类，这是为了最大限度的减少耦合，但是UI控件可以不遵循这个原则，因为控件与前端框架的耦合是无法避免的，使用接口带来的好处不明显

#所有API都应该尽量不可变，没有副作用，尤其是涉及多线程的API

#凡是名字比较长或者获取它们开销比较大的属性，方法返回值，如果在同一个作用域中被访问两次，都应该使用一个局部变量将他们缓存起来

#如果BCL中存在指定功能的API，且该API可满足要求，则应该尽量使用原生的API，但还是最好使用一个接口之类的东西把它们封装起来，这样可以为更换实现提供方便

#如果方法执行过程中出现了与预期不符的情况，则根据以下原则决定是否抛出异常：
1.如果可以自动纠正错误，则纠正错误，且不抛出异常，例如：假设有一个根据范围返回集合中元素的API，但是该范围超出了集合的范围（例如集合中只有1个元素，但是范围从索引10开始），则此时应该返回一个空集合，不抛出异常
2.如果出现该情况，导致方法执行后结果不同，则抛出异常，例如：假设有一个通过键读取字典中值的API，如果字典中不存在指定的键，则此时方法无法返回或只能返回默认值，此时应该抛出异常
3.如果出现该情况，不会影响方法的执行结果，则不应该抛出异常，例如：假设有一个根据键替换字典中元素的API，但此时字典中没有对应的键，这种情况下不应该抛出异常，而是直接将该元素添加进去，因为在外界看来，结果都是该位置被放上了替换后的元素

#底层模块的API越多，上层模块可用的API数量就越多，所需要依赖的模块数量越少，但是代价是底层模块会更加复杂和臃肿，而且可能违反单一职责原则，基于这个特点，制定本规范：
1.绝对不要违反单一职责原则
2.底层模块应该尽量大而全，但是也应该多声明接口，少声明接口的实现，这种设计是针对这两个方向最恰当的平衡

#对于面对的业务情况非常复杂，难以归纳，需要很长时间开发的功能，实现原则是：
1.为项目进度考虑，该接口的实现不必考虑到所有情况，如果以后在某些环境中无法工作，再将其重构
2.但是接口的设计必须预留足够空间，确保在出现上一条所述的情况时，只需要重构实现，不需要重构接口

#对于通过#region将代码分段，推荐做法是：
按照访问修饰符进行一级分类，这样可以让阅读代码的人只关注公开成员，暂时忽略其他成员
有特殊意义的成员应该放在专门的地方，例如，构造函数应该单独放置，不跟公开成员和内部成员放在一起
如果一个公开方法具有私有的辅助方法，那么它们应该放在一起，即便该辅助方法是私有的，因为它们之间具有强关联